#include <stdio.h>

int main()
{
	unsigned char ch = 255, mask = 0x7F;	// 문자형 변수에 225를 대입한다. 2진수로 표현하면 11111111이 된다.

	printf("%d\n", ch);	// 255
	printf("%d\n", ch & mask);	// 127 : ch & mask의 값은 논리곱으로서, ch 변수의 2진 표현 값이 1111 1111, mask 변수의 2진 표현 값이 0111 1111이므로 비트곱 연산에 의해 0111 1111이 되며, 이는 10진수로 127이다. 비트곱 연산은 모두 1인 경우만 1이 되고 하나라도 0이면 0값을 갖는다.
	printf("%d\n", (char) ~ch);	// 0 : ~ch의 값은 모든 비트의 값을 반전한다. char형 변수는 1바이트 길이이기 때문에 1111 1111이 0000 0000으로 변한다. 2진수의 8비트는 1바이트이다.
	printf("%d\n", ch ^ ch);	// 0 : ch ^ ch의 값은 배타적 비트합의 값으로서, 둘 중 하나만 참인 경우에만 참이 된다. 배타적 비트합 연산은 두 개의 비트가 서로 다른 경우에만 1이 되며, 둘 다 0이거나 둘 다 1이면 결과는 0이 된다. ch ^ ch는 ch의 값을 0으로 만들 때 사용되기도 한다.
	printf("%d\n", ch >> 1);	// 127 : 쉬프트 연산자(>>)는 모든 비트를 한 자리씩 오른쪽으로 옮기는 역할을 한다. 컴퓨터는 내부적으로 덧셈과 뺄셈만을 할 수 있기 때문에 나눗셈은 바로 이 연산자를 사용해 구현한다.
	printf("%d\n", mask << 1);	// 254 : 쉬프트 연산자(<<)는 모든 비트를 한 자리씩 왼쪽으로 옮기는 역할을 한다. 곱셈은 이 연산자를 사용해 구현한다.
}

/*
- 컴퓨터는 음수를 표현하기 위해 내부적으로 첫째 비트를 사용한다. 첫째 비트가 0이면 양수, 1이면 음수를 표현한다. 또한, 음수인 경우 원래의 값에 1을 더한 2의 보수라는 개념을 사용한다.
*/